
import { supabase } from '@/lib/supabase'
import { RundownItem } from '@/hooks/useRundownItems'
import { Column } from '@/hooks/useColumnsManager'
import { SavedRundown } from './types'
import { mapDatabaseToRundown } from './dataMapper'

export class RundownOperations {
  constructor(
    private user: any,
    private saveRundown: (rundown: SavedRundown) => Promise<string>,
    private setSavedRundowns: React.Dispatch<React.SetStateAction<SavedRundown[]>>
  ) {}

  async updateRundown(
    id: string,
    title: string,
    items: RundownItem[],
    silent: boolean = false,
    archived: boolean = false,
    columns?: Column[],
    timezone?: string,
    startTime?: string,
    icon?: string,
    undoHistory?: any[],
    teamId?: string
  ) {
    if (!this.user) {
      throw new Error('User not authenticated');
    }

    try {
      const updateData = {
        title,
        items,
        archived,
        columns,
        timezone,
        start_time: startTime,
        icon,
        undo_history: undoHistory,
        team_id: teamId,
        user_id: this.user.id,
        updated_at: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('rundowns')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      const updatedRundown = mapDatabaseToRundown(data);
      
      this.setSavedRundowns(prevRundowns => 
        prevRundowns.map(r => r.id === id ? updatedRundown : r)
      );
    } catch (error) {
      console.error('Error updating rundown:', error);
      throw error;
    }
  }

  async deleteRundown(id: string) {
    if (!this.user) {
      throw new Error('User not authenticated');
    }

    try {
      const { error } = await supabase
        .from('rundowns')
        .delete()
        .eq('id', id);

      if (error) throw error;

      this.setSavedRundowns(prevRundowns => 
        prevRundowns.filter(r => r.id !== id)
      );
    } catch (error) {
      console.error('Error deleting rundown:', error);
      throw error;
    }
  }

  async archiveRundown(id: string) {
    const rundown = await this.getRundownById(id);
    if (rundown) {
      return this.updateRundown(id, rundown.title, rundown.items, false, true);
    }
  }

  async duplicateRundown(rundown: SavedRundown) {
    if (!this.user) {
      throw new Error('User not authenticated');
    }

    const duplicatedRundown: SavedRundown = {
      ...rundown,
      id: '', // Will be generated by database
      title: `${rundown.title} (Copy)`,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    return this.saveRundown(duplicatedRundown);
  }

  private async getRundownById(id: string): Promise<SavedRundown | null> {
    try {
      const { data, error } = await supabase
        .from('rundowns')
        .select('*')
        .eq('id', id)
        .single();

      if (error) throw error;
      return mapDatabaseToRundown(data);
    } catch (error) {
      console.error('Error fetching rundown:', error);
      return null;
    }
  }
}
